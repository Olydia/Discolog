\chapter{Implementation} % Main chapter title

\label{Chapter 4} % For referencing the chapter elsewhere, use \ref{Chapter1} 

\lhead{Chapter 4. \emph{Discologapproach}}
\section{Discolog approach}
\begin{algorithm}
	\caption{DiscoLog algorithm}\label{euclid}
	\begin{algorithmic}[]
		\Procedure{Discolog}{HTN,Goal}
		\State $\textit{HTN} \gets\textit{ConstructModel()} $
		\State $\pi \gets Disco \textit{(HTN,Goal)}$
		\If {$ \pi \gets\textit{Success} $} 
		\State \Return $\textit{Success} $
		\Else 
		\State$ plan \gets Recover(Goal)$
		\If {(plan = \textit{null})}
		\State \Return Failure
		\Else 
		\For{$ \textbf{each}\text{ action }\textit{ai} \in plan $}
		\State  $\textit{Discolog} \text{(HTN,ai)}$
		\EndFor
		\EndIf
		\EndIf
		\\
		\EndProcedure \textbf{EndProcedure}
		\State 
		\Procedure{Recover}{Goal}
		\State $\textit{listCandidates}\gets\textit{findCandidate}{(G)} $
		\If {$ \textit{listCandidates = }\emptyset $} 
		\State \Return $\textit{null} $
		\Else 
		\State $\Pi \gets \emptyset$
		
		\For{$ \textbf{each} \textit{ candidate} \in \textit{listCandidates}$}
		\State $\Pi += InvokeSTRIPS(candidate,CurrentState)$
		\State  $Cost \gets \{ cost(\pi) | \pi \in  \Pi \} $
		\EndFor
		\EndIf
		\State \Return $\pi \in \Pi \text{ with minimum cost}(\pi)$
		\\
		\EndProcedure \textbf{EndProcedure}
		
		\State 
		\Procedure{FindCandidate}{Goal}
		\For{$ \textbf{each} \textit{ child} \in \textit{Goal}$}
		
		\If {$\text{(precondition(child)!=} \emptyset \text{ and}$
			\State$ \textbf{ status} (child)\notin\{\text{Done, Live, Blocked}\})$}
		\State $  \text{ add precondition(child) to candidates}$
		
		\ElsIf{$\text{(postcondition(child)!=}\emptyset 
			\text{ and } \textbf{ status} \text{(child)} \in \{\text{Failed}\}$}
		\State $\text{add postcondition(child) to candidates}$
		\EndIf
		\If {$(\textbf{status} \in \{\text{Live}\}\text{ and nonprimitive(child) and applicability(child)!=}\emptyset)$}
		\State add Applicabilitcondition(child) to candidates
		\EndIf
		\State $\textit{findCandidate} (children(child))$
		\EndFor
		\State \Return candidates
		\\
		\EndProcedure \textbf{EndProcedure}
		
	\end{algorithmic}
\end{algorithm}
\section{Description of the algorithm \ref{euclid}}

Let \textit{HTN} be a model of an Hierarchical Task Network with a top level task \textit{Goal} to achieve.To achieve \textit{Goal} Disco proceed as follow:


Starting from the top level goal \textit{Goal}, Disco recursively decomposes tasks until it reaches a set of primitives tasks that can be directelly executed in the real world to achieve \textit{Goal}.
Each task in Disco has a \textit{status(Task)} $\in$ \{Live,Blocked,Done,Failed,Succeed\}.
\par Before decomposing a non primitive task or executing primitives task, Disco evaluate the precondition of the this task. If the current state holds the preconditions(Task) then status(Task) is updated to Live. otherwise, Status(Task)= Blocked and the HTN execution is blocked.
The same, after the execution of a primitive task(execution of the grounding script), Disco evaluate its postconditions. If postconditions(Task) are valid in the current state the status(Task) is updated to done or succeed, otherwise status(Task)= failed and the HTN execution become blocked.


At the end of the process, Disco(HTN,Goal) returns either Success(Goal is achieved) or failure if Disco faces breakdown. These breakdowns are detected if the top level goal is not achieved i.e Status(Goal) != Done and Disco has no decomposition or execution to propose. 

When such breakdown occurs, the recovery algorithm will, first look over the \textit{Goal} and its children to find task candidates which can be repaired from the current state in order to recover from the breakdown. This process is handled by the procedure FindCandidates() described in the Algorithm \ref{euclid}.
As presented previously, a breakdown occur in a HTN if one of the task condition fail. Thus repairing a task using PROLOG is possible by repairing its failed condition :
\begin{itemize}
	\item	If the status of task is neither done nor live then the algorithm will attempts to repair its preconditions
	\item	If the status of task is failed then its postcondition are not valid and the repair algorithm will attempts to repair these postconditions.
	\item	if the task is nonprimitive and all its applicability conditions are invalid in the current state then the algorithm will attempts te replan to satisfy one of its applicability condition. 
\end{itemize}

For example, the moveandpaint task which breakdowns in the execution of the walk task because its precondition "isOpen(door)" is no longer valid in the current state. 

Once, the list of candidate is identified, the prolog STRIPS planner is called for each candidate and the solution with the shorter plan is returned to Disco to be executed in the real world.

